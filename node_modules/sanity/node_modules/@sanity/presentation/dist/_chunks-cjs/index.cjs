"use strict";
var jsxRuntime = require("react/jsx-runtime"), react = require("react"), sanity = require("sanity"), icons = require("@sanity/icons"), ui = require("@sanity/ui"), styledComponents = require("styled-components"), get = require("lodash.get"), rxjs = require("rxjs"), router$1 = require("sanity/router"), uuid = require("@sanity/uuid");
function _interopDefaultCompat(e) {
  return e && typeof e == "object" && "default" in e ? e : { default: e };
}
var get__default = /* @__PURE__ */ _interopDefaultCompat(get);
const DEFAULT_TOOL_ICON = icons.ComposeIcon, DEFAULT_TOOL_NAME = "presentation", DEFAULT_TOOL_TITLE = "Presentation", COMMENTS_INSPECTOR_NAME = "sanity/structure/comments", EDIT_INTENT_MODE = "presentation", MAX_TIME_TO_OVERLAYS_CONNECTION = 3e3, API_VERSION = "2023-10-16", MIN_LOADER_QUERY_LISTEN_HEARTBEAT_INTERVAL = 1e3, LIVE_QUERY_CACHE_BATCH_SIZE = 100, LIVE_QUERY_CACHE_SIZE = 2048, POPUP_CHECK_INTERVAL = 1e3;
function keysOf(value) {
  return Object.keys(value);
}
function setKey(source, key, value) {
  return {
    ...source,
    [key]: value
  };
}
function props(options = {}) {
  return (source) => new rxjs.Observable((observer) => source.subscribe(observer)).pipe(
    rxjs.switchMap((object2) => {
      const keyObservables = keysOf(object2).map((key) => {
        const value = object2[key];
        return rxjs.isObservable(value) ? rxjs.from(value).pipe(rxjs.map((val) => [key, val])) : rxjs.of([key, value]);
      });
      return options.wait ? rxjs.combineLatest(keyObservables).pipe(
        rxjs.map((pairs) => pairs.reduce((acc, [key, value]) => setKey(acc, key, value), {}))
      ) : rxjs.from(keyObservables).pipe(
        rxjs.mergeAll(),
        rxjs.scan((acc, [key, value]) => setKey(acc, key, value), {})
      );
    })
  );
}
const INITIAL_STATE = { locations: [] };
function getDocumentId(value) {
  return sanity.isReference(value) ? value._ref : "_id" in value ? value._id : void 0;
}
function cleanPreviewable(id, previewable) {
  const clean = id ? { ...previewable, _id: id } : { ...previewable };
  return clean._type === "reference" && (delete clean._type, delete clean._ref, delete clean._weak, delete clean._dataset, delete clean._projectId, delete clean._strengthenOnPublish), clean;
}
function listen(id, fields, store5) {
  const query = `*[_id==$id][0]{${fields.join(", ")}}`, params = { id };
  return store5.listenQuery(query, params, {
    perspective: "previewDrafts"
  });
}
function observeDocument(value, paths, store5) {
  if (!value || typeof value != "object")
    return rxjs.of(value);
  const id = getDocumentId(value), currentValue = cleanPreviewable(id, value), headlessPaths = paths.filter((path) => !(path[0] in currentValue));
  if (id && headlessPaths.length) {
    const fields = [...new Set(headlessPaths.map((path) => path[0]))];
    return listen(id, fields, store5).pipe(
      rxjs.switchMap((snapshot) => snapshot ? observeDocument(snapshot, paths, store5) : rxjs.of(null))
    );
  }
  const leads = {};
  paths.forEach((path) => {
    const [head, ...tail] = path;
    leads[head] || (leads[head] = []), leads[head].push(tail);
  });
  const next = Object.keys(leads).reduce((res, head) => {
    const tails = leads[head].filter((tail) => tail.length > 0);
    return tails.length === 0 ? res[head] = sanity.isRecord(value) ? value[head] : void 0 : res[head] = observeDocument(value[head], tails, store5), res;
  }, currentValue);
  return rxjs.of(next).pipe(props({ wait: !0 }));
}
function observeForLocations(documentId, resolver, documentStore) {
  const { select } = resolver, paths = Object.values(select).map((value) => String(value).split(".")) || [];
  return observeDocument({ _type: "reference", _ref: documentId }, paths, documentStore).pipe(
    rxjs.map((doc2) => Object.keys(select).reduce((acc, key) => (acc[key] = get__default.default(doc2, select[key]), acc), {})),
    rxjs.map(resolver.resolve)
  );
}
function useDocumentLocations(props2) {
  const { id, resolvers, type } = props2, documentStore = sanity.useDocumentStore(), [locationsState, setLocationsState] = react.useState(INITIAL_STATE), resolver = resolvers && (typeof resolvers == "function" ? resolvers : resolvers[type]), [locationsStatus, setLocationsStatus] = react.useState(
    resolver ? "resolving" : "empty"
  ), result = react.useMemo(() => {
    if (resolver) {
      if (typeof resolver == "function") {
        const _result = resolver({ id, type }, { documentStore });
        return rxjs.isObservable(_result) ? _result : rxjs.of(_result);
      }
      return "select" in resolver && "resolve" in resolver ? observeForLocations(id, resolver, documentStore) : rxjs.of(resolver);
    }
  }, [documentStore, id, resolver, type]);
  return react.useEffect(() => {
    const sub = result?.subscribe((state) => {
      setLocationsState(state || INITIAL_STATE), setLocationsStatus(state ? "resolved" : "empty");
    });
    return () => sub?.unsubscribe();
  }, [result]), {
    state: locationsState,
    status: locationsStatus
  };
}
const presentationLocaleNamespace = "presentation", presentationUsEnglishLocaleBundle = sanity.defineLocaleResourceBundle({
  locale: "en-US",
  namespace: presentationLocaleNamespace,
  resources: () => Promise.resolve().then(function() {
    return require("./resources.cjs");
  })
}), PresentationContext = react.createContext(null);
function usePresentationTool() {
  const presentation = react.useContext(PresentationContext);
  if (!presentation)
    throw new Error("Presentation context is missing");
  return presentation;
}
function useCurrentPresentationToolName() {
  try {
    return usePresentationTool().name;
  } catch {
    return;
  }
}
const TONE_ICONS = {
  positive: icons.InfoOutlineIcon,
  caution: icons.WarningOutlineIcon,
  critical: icons.ErrorOutlineIcon
};
function LocationsBanner(props2) {
  const { documentId, isResolving, options, schemaType, showPresentationTitle } = props2, { locations, message, tone } = props2.state, len = locations?.length || 0, { t } = sanity.useTranslation(presentationLocaleNamespace), presentation = react.useContext(PresentationContext), [expanded, setExpanded] = react.useState(!1), toggle = react.useCallback(() => {
    len && setExpanded((v) => !v);
  }, [len]), title = isResolving ? t("locations-banner.resolving.text") : message || t("locations-banner.locations-count", { count: len });
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { padding: 1, radius: 2, border: !0, tone, children: /* @__PURE__ */ jsxRuntime.jsxs("div", { style: { margin: -1 }, children: [
    !locations && /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "flex-start", gap: 3, padding: 3, children: [
      tone && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: "none", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: react.createElement(TONE_ICONS[tone]) }) }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Text, { size: 1, weight: "medium", children: [
        showPresentationTitle && /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
          options.title || DEFAULT_TOOL_TITLE,
          " \xB7 "
        ] }),
        title
      ] }) })
    ] }),
    locations && /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
      /* @__PURE__ */ jsxRuntime.jsx(
        ui.Card,
        {
          as: len ? "button" : void 0,
          onClick: toggle,
          padding: 3,
          radius: 1,
          tone: "inherit",
          children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 3, children: [
            /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: "none", children: isResolving ? /* @__PURE__ */ jsxRuntime.jsx(ui.Spinner, { size: 1 }) : /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: len === 0 ? /* @__PURE__ */ jsxRuntime.jsx(icons.InfoOutlineIcon, {}) : /* @__PURE__ */ jsxRuntime.jsx(
              icons.ChevronRightIcon,
              {
                style: {
                  transform: `rotate(${expanded ? "90deg" : 0})`,
                  transition: "transform 100ms ease-in-out"
                }
              }
            ) }) }),
            /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Text, { size: 1, weight: "medium", children: [
              showPresentationTitle && /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
                options.title || DEFAULT_TOOL_TITLE,
                " \xB7 "
              ] }),
              title
            ] }) })
          ] })
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { hidden: !expanded, marginTop: 1, space: 1, children: locations.map((l, index) => /* @__PURE__ */ jsxRuntime.jsx(
        LocationItem,
        {
          active: (options.name || DEFAULT_TOOL_NAME) === presentation?.name && l.href === presentation?.params.preview,
          documentId,
          documentType: schemaType.name,
          node: l,
          toolName: options.name || DEFAULT_TOOL_NAME
        },
        index
      )) })
    ] })
  ] }) });
}
function LocationItem(props2) {
  const { documentId, documentType, node, active, toolName } = props2, presentation = react.useContext(PresentationContext), currentPresentationToolName = useCurrentPresentationToolName(), isCurrentTool = toolName === currentPresentationToolName, navigate = presentation?.navigate, presentationLinkProps = router$1.useIntentLink({
    intent: "edit",
    params: {
      id: documentId,
      type: documentType,
      mode: "presentation",
      presentation: toolName,
      ...presentation?.structureParams,
      preview: node.href
    }
  }), handleCurrentToolClick = react.useCallback(() => {
    navigate?.({}, { preview: node.href });
  }, [node.href, navigate]);
  return /* @__PURE__ */ react.createElement(
    ui.Card,
    {
      ...isCurrentTool ? {} : presentationLinkProps,
      as: "a",
      key: node.href,
      onClick: isCurrentTool ? handleCurrentToolClick : presentationLinkProps.onClick,
      padding: 3,
      radius: 1,
      pressed: active,
      tone: "inherit"
    },
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 3, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: "none", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(icons.DesktopIcon, {}) }) }),
      /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { flex: 1, space: 2, children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "medium", children: node.title }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, textOverflow: "ellipsis", children: node.href })
      ] })
    ] })
  );
}
const PresentationDocumentContext = react.createContext(
  null
), LocationStack = styledComponents.styled(ui.Stack)`
  min-height: ${ui.rem(42)};

  & + &:empty {
    display: none;
  }
`;
function PresentationDocumentHeader(props2) {
  const { documentId, options, schemaType } = props2, context = react.useContext(PresentationDocumentContext), { state, status } = useDocumentLocations({
    id: documentId,
    resolvers: options.resolve?.locations || options.locate,
    type: schemaType.name
  });
  if (context && context.options[0] !== options || status === "empty")
    return null;
  const contextOptions = context?.options || [];
  return /* @__PURE__ */ jsxRuntime.jsx(LocationStack, { marginBottom: 5, space: 5, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { space: 2, children: contextOptions.map((options2, idx) => /* @__PURE__ */ jsxRuntime.jsx(
    LocationsBanner,
    {
      documentId,
      isResolving: status === "resolving",
      options: options2,
      schemaType,
      showPresentationTitle: contextOptions.length > 1,
      state
    },
    idx
  )) }) });
}
function PresentationDocumentProvider(props2) {
  const { children, options } = props2, parent = react.useContext(PresentationDocumentContext), parentRegister = parent?.register, [optionsArray, setOptionsArray] = react.useState(() => []), register = react.useCallback(
    (options2) => parentRegister ? parentRegister(options2) : (setOptionsArray((prev) => [options2].concat(prev)), () => {
      setOptionsArray((prev) => prev.filter((o) => o !== options2));
    }),
    [parentRegister]
  ), registerRef = react.useRef(register);
  registerRef.current = register;
  const context = react.useMemo(
    () => ({
      options: parent?.options || optionsArray,
      register
    }),
    [optionsArray, parent, register]
  );
  return react.useLayoutEffect(() => registerRef.current(options), [options]), /* @__PURE__ */ jsxRuntime.jsx(PresentationDocumentContext.Provider, { value: context, children });
}
const openInStructure = sanity.defineDocumentFieldAction({
  name: "presentation/openInStructure",
  useAction({ documentId, documentType, path }) {
    const workspace = sanity.useWorkspace(), { navigateIntent } = router$1.useRouter(), presentation = react.useContext(PresentationContext), defaultStructureTool = react.useMemo(
      () => findStructureTool(workspace.tools, documentId, documentType),
      [documentId, documentType, workspace.tools]
    );
    return {
      type: "action",
      hidden: !presentation || path.length > 0 || !defaultStructureTool,
      icon: defaultStructureTool?.icon || icons.MasterDetailIcon,
      title: `Open in ${defaultStructureTool?.title || "Structure"}`,
      onAction() {
        navigateIntent("edit", {
          id: documentId,
          type: documentType,
          mode: "structure",
          path: sanity.pathToString(path)
        });
      },
      renderAsButton: !0
    };
  }
});
function findStructureTool(tools, documentId, documentType) {
  const results = tools.map((t) => {
    const match = t.canHandleIntent?.(
      "edit",
      {
        id: documentId,
        type: documentType,
        mode: "structure"
      },
      {}
    );
    return { tool: t, match };
  }), modeMatches = results.filter((t) => sanity.isRecord(t.match) && t.match.mode);
  return modeMatches.length > 0 ? modeMatches[0].tool : results.filter((t) => t.match)[0]?.tool;
}
const preservedSearchParamKeys = [
  "preview",
  "perspective",
  "viewport"
];
function getIntentState(intent, params, routerState, payload) {
  const { id, mode, path, presentation, type, ...searchParams } = params, _searchParams = {
    ...(routerState?._searchParams || []).filter(([key]) => preservedSearchParamKeys.includes(key)).reduce((acc, [key, value]) => ({ ...acc, [key]: value }), {}),
    ...searchParams
  };
  return intent === "edit" && id ? (_searchParams.preview = _searchParams.preview || new URLSearchParams(window.location.search).get("preview") || "/", {
    type: type || "*",
    id: sanity.getPublishedId(id),
    path,
    _searchParams: Object.entries(_searchParams)
  }) : intent === "create" ? (_searchParams.preview = _searchParams.preview || new URLSearchParams(window.location.search).get("preview") || "/", payload && typeof payload == "object" && (_searchParams.templateParams = router$1.encodeJsonParams(payload)), {
    type: type || "*",
    id: id || uuid.uuid(),
    _searchParams: Object.entries(_searchParams)
  }) : { intent, params, payload };
}
function PresentationSpinner() {
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", direction: "column", height: "fill", justify: "center", style: { width: "100%" }, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Spinner, {}) });
}
const router = router$1.route.create("/", { __unsafe_disableScopedSearchParams: !0 }, [
  router$1.route.intents("/intent"),
  router$1.route.create(":type", [router$1.route.create(":id", [router$1.route.create(":path")])])
]), PresentationTool = react.lazy(() => Promise.resolve().then(function() {
  return require("./PresentationToolGrantsCheck.cjs");
}).then(function(n) {
  return n.PresentationToolGrantsCheck;
})), BroadcastDisplayedDocument = react.lazy(() => Promise.resolve().then(function() {
  return require("./BroadcastDisplayedDocument.cjs");
}));
function defineLocations(resolver) {
  return resolver;
}
function defineDocuments(resolvers) {
  return resolvers;
}
const presentationTool = sanity.definePlugin((options) => {
  const toolName = options.name || DEFAULT_TOOL_NAME;
  "locate" in options && console.warn("Presentation\u2019s `locate` option is deprecated. Use `resolve.locations` instead.");
  const hasLocationsResolver = !!(options.resolve?.locations || options.locate);
  function PresentationDocumentInput(props2) {
    const value = props2.value, documentId = value?._id ? sanity.getPublishedId(value?._id) : void 0;
    return sanity.isDocumentSchemaType(props2.schemaType) ? /* @__PURE__ */ jsxRuntime.jsxs(PresentationDocumentProvider, { options, children: [
      hasLocationsResolver && documentId && /* @__PURE__ */ jsxRuntime.jsx(
        PresentationDocumentHeader,
        {
          documentId,
          options,
          schemaType: props2.schemaType
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsx(react.Suspense, { fallback: /* @__PURE__ */ jsxRuntime.jsx(PresentationSpinner, {}), children: props2.renderDefault(props2) }),
      /* @__PURE__ */ jsxRuntime.jsx(react.Suspense, { children: /* @__PURE__ */ jsxRuntime.jsx(BroadcastDisplayedDocument, { value }, documentId) }, "broadcast-displayed-document")
    ] }) : props2.renderDefault(props2);
  }
  function canHandleCreateIntent(params) {
    return !("type" in params) || "presentation" in params && params.presentation !== toolName ? !1 : "template" in params ? { template: !0 } : !0;
  }
  function canHandleEditIntent(params) {
    return !("type" in params) || !("id" in params) || "presentation" in params && params.presentation !== toolName ? !1 : "mode" in params ? { mode: params.mode === EDIT_INTENT_MODE } : !0;
  }
  return {
    i18n: {
      bundles: [presentationUsEnglishLocaleBundle]
    },
    document: {
      unstable_fieldActions: (prev) => [
        ...prev.filter((a) => a.name !== openInStructure.name),
        // prevent duplication
        openInStructure
      ]
    },
    form: {
      components: {
        input: PresentationDocumentInput
      }
    },
    tools: [
      {
        icon: options.icon || DEFAULT_TOOL_ICON,
        name: toolName,
        title: options.title,
        component: PresentationTool,
        options,
        canHandleIntent(intent, params) {
          return intent === "create" ? canHandleCreateIntent(params) : intent === "edit" ? canHandleEditIntent(params) : !1;
        },
        getIntentState,
        router
      }
    ]
  };
}), PresentationNavigateContext = react.createContext(
  null
);
function usePresentationNavigate() {
  const navigate = react.useContext(PresentationNavigateContext);
  if (!navigate)
    throw new Error("Presentation navigate context is missing");
  return navigate;
}
const PresentationParamsContext = react.createContext(null);
function usePresentationParams(throwOnMissingContext = !0) {
  const params = react.useContext(PresentationParamsContext);
  if (throwOnMissingContext && !params)
    throw new Error("Presentation params context is missing");
  return params;
}
const SharedStateContext = react.createContext(null), useSharedState = (key, value) => {
  const context = react.useContext(SharedStateContext);
  if (!context)
    throw new Error("Preview Snapshots context is missing");
  const { setValue } = context;
  react.useEffect(() => {
    setValue(key, value);
  }, [key, value, setValue]);
};
var store;
function getGlobalConfig(config2) {
  return {
    lang: config2?.lang ?? store?.lang,
    message: config2?.message,
    abortEarly: config2?.abortEarly ?? store?.abortEarly,
    abortPipeEarly: config2?.abortPipeEarly ?? store?.abortPipeEarly,
    skipPipe: config2?.skipPipe
  };
}
var store2;
function getGlobalMessage(lang) {
  return store2?.get(lang);
}
var store3;
function getSchemaMessage(lang) {
  return store3?.get(lang);
}
var store4;
function getSpecificMessage(reference, lang) {
  return store4?.get(reference)?.get(lang);
}
function _stringify(input) {
  let type = typeof input;
  return type === "object" && (type = (input && Object.getPrototypeOf(input)?.constructor?.name) ?? "null"), type === "string" ? `"${input}"` : type === "number" || type === "bigint" || type === "boolean" ? `${input}` : type;
}
function _addIssue(context, label, dataset, config2, other) {
  const input = other && "input" in other ? other.input : dataset.value, expected = other?.expected ?? context.expects, received = other?.received ?? _stringify(input), issue = {
    kind: context.kind,
    type: context.type,
    input,
    expected,
    received,
    message: `Invalid ${label}: ${expected ? `Expected ${expected} but r` : "R"}eceived ${received}`,
    // @ts-expect-error
    requirement: context.requirement,
    path: other?.path,
    issues: other?.issues,
    lang: config2.lang,
    abortEarly: config2.abortEarly,
    abortPipeEarly: config2.abortPipeEarly,
    skipPipe: config2.skipPipe
  }, isSchema = context.kind === "schema", message = (
    // @ts-expect-error
    context.message ?? getSpecificMessage(context.reference, issue.lang) ?? (isSchema ? getSchemaMessage(issue.lang) : null) ?? config2.message ?? getGlobalMessage(issue.lang)
  );
  message && (issue.message = typeof message == "function" ? message(issue) : message), isSchema && (dataset.typed = !1), dataset.issues ? dataset.issues.push(issue) : dataset.issues = [issue];
}
function _isAllowedObjectKey(key) {
  return key !== "__proto__" && key !== "prototype" && key !== "constructor";
}
var ValiError = class extends Error {
  /**
   * The error issues.
   */
  issues;
  /**
   * Creates a Valibot error with useful information.
   *
   * @param issues The error issues.
   */
  constructor(issues) {
    super(issues[0].message), this.name = "ValiError", this.issues = issues;
  }
};
function minLength(requirement, message) {
  return {
    kind: "validation",
    type: "min_length",
    reference: minLength,
    async: !1,
    expects: `>=${requirement}`,
    requirement,
    message,
    _run(dataset, config2) {
      return dataset.typed && dataset.value.length < this.requirement && _addIssue(this, "length", dataset, config2, {
        received: `${dataset.value.length}`
      }), dataset;
    }
  };
}
function getFallback(schema, dataset, config2) {
  return typeof schema.fallback == "function" ? (
    // @ts-expect-error
    schema.fallback(dataset, config2)
  ) : (
    // @ts-expect-error
    schema.fallback
  );
}
function fallback(schema, fallback2) {
  return {
    ...schema,
    fallback: fallback2,
    _run(dataset, config2) {
      return schema._run(dataset, config2), dataset.issues ? { typed: !0, value: getFallback(this, dataset, config2) } : dataset;
    }
  };
}
function getDefault(schema, dataset, config2) {
  return typeof schema.default == "function" ? (
    // @ts-expect-error
    schema.default(dataset, config2)
  ) : (
    // @ts-expect-error
    schema.default
  );
}
function boolean(message) {
  return {
    kind: "schema",
    type: "boolean",
    reference: boolean,
    expects: "boolean",
    async: !1,
    message,
    _run(dataset, config2) {
      return typeof dataset.value == "boolean" ? dataset.typed = !0 : _addIssue(this, "type", dataset, config2), dataset;
    }
  };
}
function object(entries, message) {
  return {
    kind: "schema",
    type: "object",
    reference: object,
    expects: "Object",
    async: !1,
    entries,
    message,
    _run(dataset, config2) {
      const input = dataset.value;
      if (input && typeof input == "object") {
        dataset.typed = !0, dataset.value = {};
        for (const key in this.entries) {
          const value2 = input[key], valueDataset = this.entries[key]._run(
            { typed: !1, value: value2 },
            config2
          );
          if (valueDataset.issues) {
            const pathItem = {
              type: "object",
              origin: "value",
              input,
              key,
              value: value2
            };
            for (const issue of valueDataset.issues)
              issue.path ? issue.path.unshift(pathItem) : issue.path = [pathItem], dataset.issues?.push(issue);
            if (dataset.issues || (dataset.issues = valueDataset.issues), config2.abortEarly) {
              dataset.typed = !1;
              break;
            }
          }
          valueDataset.typed || (dataset.typed = !1), (valueDataset.value !== void 0 || key in input) && (dataset.value[key] = valueDataset.value);
        }
      } else
        _addIssue(this, "type", dataset, config2);
      return dataset;
    }
  };
}
function optional(wrapped, ...args) {
  const schema = {
    kind: "schema",
    type: "optional",
    reference: optional,
    expects: `${wrapped.expects} | undefined`,
    async: !1,
    wrapped,
    _run(dataset, config2) {
      return dataset.value === void 0 && ("default" in this && (dataset.value = getDefault(
        this,
        dataset,
        config2
      )), dataset.value === void 0) ? (dataset.typed = !0, dataset) : this.wrapped._run(dataset, config2);
    }
  };
  return 0 in args && (schema.default = args[0]), schema;
}
function picklist(options, message) {
  return {
    kind: "schema",
    type: "picklist",
    reference: picklist,
    expects: options.map(_stringify).join(" | ") || "never",
    async: !1,
    options,
    message,
    _run(dataset, config2) {
      return this.options.includes(dataset.value) ? dataset.typed = !0 : _addIssue(this, "type", dataset, config2), dataset;
    }
  };
}
function record(key, value2, message) {
  return {
    kind: "schema",
    type: "record",
    reference: record,
    expects: "Object",
    async: !1,
    key,
    value: value2,
    message,
    _run(dataset, config2) {
      const input = dataset.value;
      if (input && typeof input == "object") {
        dataset.typed = !0, dataset.value = {};
        for (const entryKey in input)
          if (_isAllowedObjectKey(entryKey)) {
            const entryValue = input[entryKey], keyDataset = this.key._run(
              { typed: !1, value: entryKey },
              config2
            );
            if (keyDataset.issues) {
              const pathItem = {
                type: "record",
                origin: "key",
                input,
                key: entryKey,
                value: entryValue
              };
              for (const issue of keyDataset.issues)
                issue.path = [pathItem], dataset.issues?.push(issue);
              if (dataset.issues || (dataset.issues = keyDataset.issues), config2.abortEarly) {
                dataset.typed = !1;
                break;
              }
            }
            const valueDataset = this.value._run(
              { typed: !1, value: entryValue },
              config2
            );
            if (valueDataset.issues) {
              const pathItem = {
                type: "record",
                origin: "value",
                input,
                key: entryKey,
                value: entryValue
              };
              for (const issue of valueDataset.issues)
                issue.path ? issue.path.unshift(pathItem) : issue.path = [pathItem], dataset.issues?.push(issue);
              if (dataset.issues || (dataset.issues = valueDataset.issues), config2.abortEarly) {
                dataset.typed = !1;
                break;
              }
            }
            (!keyDataset.typed || !valueDataset.typed) && (dataset.typed = !1), keyDataset.typed && (dataset.value[keyDataset.value] = valueDataset.value);
          }
      } else
        _addIssue(this, "type", dataset, config2);
      return dataset;
    }
  };
}
function string(message) {
  return {
    kind: "schema",
    type: "string",
    reference: string,
    expects: "string",
    async: !1,
    message,
    _run(dataset, config2) {
      return typeof dataset.value == "string" ? dataset.typed = !0 : _addIssue(this, "type", dataset, config2), dataset;
    }
  };
}
function unknown() {
  return {
    kind: "schema",
    type: "unknown",
    reference: unknown,
    expects: "unknown",
    async: !1,
    _run(dataset) {
      return dataset.typed = !0, dataset;
    }
  };
}
function parse(schema, input, config2) {
  const dataset = schema._run(
    { typed: !1, value: input },
    getGlobalConfig(config2)
  );
  if (dataset.issues)
    throw new ValiError(dataset.issues);
  return dataset.value;
}
function pipe(...pipe2) {
  return {
    ...pipe2[0],
    pipe: pipe2,
    _run(dataset, config2) {
      for (let index = 0; index < pipe2.length; index++) {
        dataset = pipe2[index]._run(dataset, config2);
        const nextAction = pipe2[index + 1];
        if (config2.skipPipe || dataset.issues && (config2.abortEarly || config2.abortPipeEarly || // TODO: This behavior must be documented!
        nextAction?.kind === "schema" || nextAction?.kind === "transformation")) {
          dataset.typed = !1;
          break;
        }
      }
      return dataset;
    }
  };
}
const ACTION_IFRAME_LOADED = "ACTION_IFRAME_LOADED", ACTION_IFRAME_REFRESH = "ACTION_IFRAME_REFRESH", ACTION_IFRAME_RELOAD = "ACTION_IFRAME_RELOAD", ACTION_VISUAL_EDITING_OVERLAYS_TOGGLE = "ACTION_VISUAL_EDITING_OVERLAYS_TOGGLE", presentationReducer = (state, action) => {
  switch (action.type) {
    case ACTION_IFRAME_LOADED:
      return state.iframe.status === "loaded" ? state : {
        ...state,
        iframe: {
          ...state.iframe,
          status: "loaded"
        }
      };
    case ACTION_IFRAME_REFRESH:
      return state.iframe.status === "refreshing" ? state : {
        ...state,
        iframe: {
          ...state.iframe,
          status: "refreshing"
        }
      };
    case ACTION_IFRAME_RELOAD:
      return state.iframe.status === "reloading" ? state : {
        ...state,
        iframe: {
          ...state.iframe,
          status: "reloading"
        }
      };
    case ACTION_VISUAL_EDITING_OVERLAYS_TOGGLE:
      return toggleVisualEditingOverlays(state, action);
    default:
      return state;
  }
}, toggleVisualEditingOverlays = (state, action) => state.visualEditing.overlaysEnabled === action.enabled ? state : {
  ...state,
  visualEditing: {
    ...state.visualEditing,
    overlaysEnabled: action.enabled
  }
}, mainDocumentSchema = fallback(boolean(), !1), iframeStatusSchema = picklist(["loading", "loaded", "refreshing", "reloading"]), initStateSchema = object({
  mainDocument: mainDocumentSchema,
  iframe: object({
    status: iframeStatusSchema
  }),
  visualEditing: object({ overlaysEnabled: boolean() })
}), INITIAL_PRESENTATION_STATE = {
  mainDocument: !1,
  iframe: {
    status: "loading"
  },
  visualEditing: {
    overlaysEnabled: !1
  }
};
function presentationReducerInit(state) {
  return parse(initStateSchema, { ...INITIAL_PRESENTATION_STATE, ...state });
}
exports.ACTION_IFRAME_LOADED = ACTION_IFRAME_LOADED;
exports.ACTION_IFRAME_REFRESH = ACTION_IFRAME_REFRESH;
exports.ACTION_IFRAME_RELOAD = ACTION_IFRAME_RELOAD;
exports.ACTION_VISUAL_EDITING_OVERLAYS_TOGGLE = ACTION_VISUAL_EDITING_OVERLAYS_TOGGLE;
exports.API_VERSION = API_VERSION;
exports.COMMENTS_INSPECTOR_NAME = COMMENTS_INSPECTOR_NAME;
exports.DEFAULT_TOOL_NAME = DEFAULT_TOOL_NAME;
exports.EDIT_INTENT_MODE = EDIT_INTENT_MODE;
exports.LIVE_QUERY_CACHE_BATCH_SIZE = LIVE_QUERY_CACHE_BATCH_SIZE;
exports.LIVE_QUERY_CACHE_SIZE = LIVE_QUERY_CACHE_SIZE;
exports.MAX_TIME_TO_OVERLAYS_CONNECTION = MAX_TIME_TO_OVERLAYS_CONNECTION;
exports.MIN_LOADER_QUERY_LISTEN_HEARTBEAT_INTERVAL = MIN_LOADER_QUERY_LISTEN_HEARTBEAT_INTERVAL;
exports.POPUP_CHECK_INTERVAL = POPUP_CHECK_INTERVAL;
exports.PresentationContext = PresentationContext;
exports.PresentationNavigateContext = PresentationNavigateContext;
exports.PresentationParamsContext = PresentationParamsContext;
exports.PresentationSpinner = PresentationSpinner;
exports.SharedStateContext = SharedStateContext;
exports.defineDocuments = defineDocuments;
exports.defineLocations = defineLocations;
exports.minLength = minLength;
exports.object = object;
exports.optional = optional;
exports.pipe = pipe;
exports.presentationLocaleNamespace = presentationLocaleNamespace;
exports.presentationReducer = presentationReducer;
exports.presentationReducerInit = presentationReducerInit;
exports.presentationTool = presentationTool;
exports.record = record;
exports.string = string;
exports.unknown = unknown;
exports.usePresentationNavigate = usePresentationNavigate;
exports.usePresentationParams = usePresentationParams;
exports.usePresentationTool = usePresentationTool;
exports.useSharedState = useSharedState;
//# sourceMappingURL=index.cjs.map
